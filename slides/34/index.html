
<section class="abstract">
  <h1 class="title">Abstract frequent optimizations</h1>
  <div class="container">
    <h2 class="bold italic accent gbrc fragment hide-after">getBoundingClientRect</h2>
    <img class="fragment hide-after" data-src="/assets/images/rect.png" height="100%"/>
    <pre class="code fragment hide-after">
      <code data-noescape data-trim>
        // module-a.js
        requestAnimationFrame(() => {
          const [right, bottom] = el.getBoundingClientRect();
        });
        // module-b.js
        requestAnimationFrame(() => {
          el.classList.add('change-size'); <span class="scream">ðŸ˜±</span>
        });
      </code>
    </pre>
    <h2 class="io bold italic accent fragment hide-after">IntersectionObserver</h2>
    <pre class="code io-spec fragment hide-after">
      <code data-noescape data-trim>
        const io = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            //   <mark>entry.boundingClientRect</mark>
            //   entry.intersectionRatio
            //   entry.intersectionRect
            //   entry.isIntersecting
            //   entry.rootBounds
            //   entry.target
            //   entry.time
          });
        });
        // observe the element
        io.observe(el);
      </code>
    </pre>
    <pre class="code gbrc-async fragment hide-after">
      <code data-noescape data-trim>
        const getBoundingClientRect = el =>
          new Promise((resolve) => {
            const io = new IntersectionObserver((entries) => {
              <mark>resolve(entries.shift().boundingClientRect);</mark>
              io.disconnect();
            });
            io.observe(el);
          });
      </code>
    </pre>
    <pre class="code touchstart fragment">
        <code data-noescape data-trim>
        const touchDevice = 'ontouchstart' in window;

        const addListener = (target, type, listener) => {
          // switch click to touchstart on touch devices
          if (type === 'click' && touchDevice) {
            <mark>type = 'touchstart';</mark>
          }

          target.addEventListener(type, listener);
        }

        </code>
    </pre>
  </div>
<aside class="notes">
* For example: getBoundingClientRect.
* Itâ€™s an amazing method that returns the coordinates, width and height, and the dimensions of an element, and itâ€™s extremely precise.
* But unfortunately, itâ€™s a synchronous method and forces a layout. This means the browser has to drop whatever is doing, and paint the screen, which can translate to visual jank.

* One possible solution is to use requestAnimationFrame, but if one of those frames changes the dimensions of the element, youâ€™ll still force a layout.

* So going back to the Intersection Observer, while I was doing the infinite loop technique. I realized a couple of things:
    * The entries on the IO have a boundingClientRect,
    and the callback executes after observing an element,
    not only when itâ€™s in view,
    so all your code needs an if statement for isIntersecting.

    * But this means, we can have an asynchronous getBoundingClientRect, and this will be the safest way to do it as of now, because youâ€™re asking to be notified of the next frame.

* Another optimization is to automatically switch all your click events to mouse down for improved perceived performance.
This will give you on average ~100ms head start, which leads me to the question that came up often:
</aside>
</section>
